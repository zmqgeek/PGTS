{"options": {"method": "ours", "eval_id": "tok", "datapath": "../data", "projs_split": "../projs_split.json", "split": "test", "file": null, "proof": null, "file_idx": 37, "proj_idx": 21, "filter": null, "path": "runs/tok/checkpoints/model_003.pth", "output_dir": "evaluation", "max_num_tactics": 300, "timeout": 600, "hammer_timeout": 100, "depth_limit": 50, "beam_width": 20, "num_tactic_candidates": 20, "lens_norm": 0.5, "tac_grammar": "tactics.ebnf", "term_embedding_dim": 256, "size_limit": 50, "embedding_dim": 256, "symbol_dim": 256, "hidden_dim": 256, "seed": 0, "num_tactics": 15025, "tac_vocab_file": "token_vocab.pickle", "cutoff_len": 30}, "results": [{"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfAXMIsPR", "success": false, "proof_gt": ["unfold checkPrfAXM in |- *.", "apply filter10IsPR with (g := fun p : nat => switchPR (charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p)) (S (S (cPair (cPairPi1 p) 0))) 0).", "apply compose1_3IsPR with (f1 := fun p : nat => charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) (cPairPi1 p)) (f2 := fun p : nat => S (S (cPair (cPairPi1 p) 0))) (f3 := fun p : nat => 0).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR.", "apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply compose1_1IsPR with (f := fun p : nat => S (cPair (cPairPi1 p) 0)).", "apply compose1_1IsPR with (f := fun p : nat => cPair (cPairPi1 p) 0).", "apply compose1_2IsPR with (f' := fun p : nat => 0).", "apply cPairPi1IsPR.", "apply const1_NIsPR.", "apply cPairIsPR.", "apply succIsPR.", "apply succIsPR.", "apply const1_NIsPR.", "apply switchIsPR."], "proof_pred": [], "time": 1.2570295333862305, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfAXMIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfMPIsPR", "success": false, "proof_gt": ["unfold checkPrfMP in |- *.", "apply compose2_3IsPR with (f1 := fun p recs : nat => wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) * (charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)) * (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs * codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))) (f2 := fun p recs : nat => S (codeApp (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs)) (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))) (f3 := fun p recs : nat => 0).", "apply compose2_2IsPR with (f := fun p recs : nat => wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (g := fun p recs : nat => charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)) * (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs * codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).", "apply filter10IsPR with (g := fun p : nat => wellFormedFormula (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "unfold wellFormedFormula in |- *.", "apply wellFormedFormulaIsPR.", "apply codeArityFIsPR.", "apply codeArityRIsPR.", "apply compose2_2IsPR with (f := fun p recs : nat => charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p))) (g := fun p recs : nat => codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs * codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 p)).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply cPairPi1IsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply cPairPi1IsPR.", "apply codeImpIsPR.", "apply eqIsPR.", "apply compose2_2IsPR with (f := fun p recs : nat => codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs) (g := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).", "apply callIsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply multIsPR.", "apply multIsPR.", "apply multIsPR.", "apply compose2_1IsPR with (f := fun p recs : nat => codeApp (pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs)) (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))).", "apply compose2_2IsPR with (f := fun p recs : nat => pred (codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs)) (g := fun p recs : nat => pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).", "apply compose2_1IsPR with (f := fun p recs : nat => codeNth (p - S (cPairPi1 (cPairPi2 (cPairPi2 p)))) recs).", "apply callIsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply predIsPR.", "apply compose2_1IsPR with (f := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).", "apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply predIsPR.", "apply codeAppIsPR.", "apply succIsPR.", "apply filter10IsPR with (g := fun _ : nat => 0).", "apply const1_NIsPR.", "apply switchIsPR."], "proof_pred": [], "time": 1.1722068786621094, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfMPIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfGENIsPR", "success": false, "proof_gt": ["unfold checkPrfGEN in |- *.", "apply compose2_3IsPR with (f1 := fun p recs : nat => charFunction 2 beq_nat (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPairPi1 p) * (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs * (1 - codeIn (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeFreeVarListFormula (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))))) (f2 := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs) (f3 := fun p recs : nat => 0).", "apply compose2_2IsPR with (f := fun p recs : nat => charFunction 2 beq_nat (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPairPi1 p)) (g := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs * (1 - codeIn (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeFreeVarListFormula (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))))).", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPairPi1 p)).", "apply compose1_2IsPR with (f := fun p : nat => cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => cPairPi1 p).", "apply compose1_2IsPR with (f := fun p : nat => 3) (f' := fun p : nat => cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply const1_NIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply cPairIsPR.", "apply cPairIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply compose2_2IsPR with (f := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs) (g := fun p recs : nat => 1 - codeIn (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeFreeVarListFormula (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))).", "apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose2_2IsPR with (f := fun p recs : nat => 1) (g := fun p recs : nat => codeIn (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeFreeVarListFormula (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)))).", "apply filter10IsPR with (g := fun _ : nat => 1).", "apply const1_NIsPR.", "apply compose2_2IsPR with (f := fun p recs : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (g := fun p recs : nat => codeFreeVarListFormula (pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs))).", "apply filter10IsPR with (g := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "apply compose2_1IsPR with (f := fun p recs : nat => pred (codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs)).", "apply compose2_1IsPR with (f := fun p recs : nat => codeNth (p - S (cPairPi2 (cPairPi2 (cPairPi2 p)))) recs).", "apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply predIsPR.", "apply codeFreeVarListFormulaIsPR.", "apply codeInIsPR.", "apply minusIsPR.", "apply multIsPR.", "apply multIsPR.", "apply callIsPR with (g := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply filter10IsPR with (g := fun _ : nat => 0).", "apply const1_NIsPR.", "apply switchIsPR."], "proof_pred": [], "time": 1.1747915744781494, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfGENIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfIMP1IsPR", "success": false, "proof_gt": ["unfold checkPrfIMP1 in |- *.", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))).", "apply compose1_2IsPR with (f := fun p : nat => 1) (f' := fun p : nat => cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p)))))).", "apply const1_NIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))).", "assumption.", "apply compose1_2IsPR with (f := fun p : nat => 1) (f' := fun p : nat => cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply const1_NIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "assumption.", "assumption.", "apply cPairIsPR.", "apply cPairIsPR.", "apply cPairIsPR.", "apply cPairIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR."], "proof_pred": [], "time": 1.2060778141021729, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfIMP1IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfIMP2IsPR", "success": false, "proof_gt": ["unfold checkPrfIMP2 in |- *.", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))).", "replace (fun p : nat => cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) with (fun p : nat => codeImp (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (codeImp (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))); [ idtac | reflexivity ].", "apply compose1_2IsPR with (f := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => codeImp (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "assumption.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "assumption.", "assumption.", "apply codeImpIsPR.", "apply codeImpIsPR.", "apply compose1_2IsPR with (f := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "assumption.", "assumption.", "apply codeImpIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "assumption.", "assumption.", "apply codeImpIsPR.", "apply codeImpIsPR.", "apply codeImpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR."], "proof_pred": [], "time": 1.214277744293213, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfIMP2IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfCPIsPR", "success": false, "proof_gt": ["unfold checkPrfCP in |- *.", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPair 1 (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPair 1 (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))).", "replace (fun p : nat => cPair 1 (cPair (cPair 1 (cPair (cPair 2 (cPairPi1 (cPairPi2 (cPairPi2 p)))) (cPair 2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))) (cPair 1 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) with (fun p : nat => codeImp (codeImp (codeNot (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeNot (cPairPi2 (cPairPi2 (cPairPi2 p))))) (codeImp (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))); [ idtac | reflexivity ].", "apply compose1_2IsPR with (f := fun p : nat => codeImp (codeNot (cPairPi1 (cPairPi2 (cPairPi2 p)))) (codeNot (cPairPi2 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => codeImp (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_2IsPR with (f := fun p : nat => codeNot (cPairPi1 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => codeNot (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "assumption.", "apply codeNotIsPR.", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "assumption.", "apply codeNotIsPR.", "apply codeImpIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "assumption.", "assumption.", "apply codeImpIsPR.", "apply codeImpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR."], "proof_pred": [], "time": 1.2014849185943604, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfCPIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfFA1IsPR", "success": false, "proof_gt": ["unfold checkPrfFA1 in |- *.", "apply filter10IsPR with (g := fun p : nat => wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) * charFunction 2 beq_nat (cPair 1 (cPair (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => wellFormedTerm (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "assumption.", "unfold wellFormedTerm in |- *.", "apply wellFormedTermIsPR.", "apply codeArityFIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))).", "replace (fun p : nat => cPair 1 (cPair (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) with (fun p : nat => codeImp (cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))))); [ idtac | reflexivity ].", "apply compose1_2IsPR with (f := fun p : nat => cPair 3 (cPair (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => codeSubFormula (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (g := fun a b : nat => cPair 3 (cPair a b)).", "assumption.", "assumption.", "apply codeForallIsPR.", "apply compose1_3IsPR with (f1 := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f2 := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f3 := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))); try assumption.", "apply codeSubFormulaIsPR.", "apply codeImpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply multIsPR."], "proof_pred": [], "time": 1.2509853839874268, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfFA1IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfFA2IsPR", "success": false, "proof_gt": ["unfold checkPrfFA2 in |- *.", "apply filter10IsPR with (g := fun p : nat => (1 - codeIn (cPairPi2 (cPairPi2 (cPairPi2 p))) (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p))))) * charFunction 2 beq_nat (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => 1 - codeIn (cPairPi2 (cPairPi2 (cPairPi2 p))) (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) (cPairPi1 p)).", "apply compose1_2IsPR with (f := fun p : nat => 1) (f' := fun p : nat => codeIn (cPairPi2 (cPairPi2 (cPairPi2 p))) (codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p))))).", "apply const1_NIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => codeFreeVarFormula (cPairPi1 (cPairPi2 (cPairPi2 p)))).", "assumption.", "apply compose1_1IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))).", "assumption.", "apply codeFreeVarFormulaIsPR.", "apply codeInIsPR.", "apply minusIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))).", "replace (fun p : nat => cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))))) with (fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p)))))); [ idtac | reflexivity ].", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 p))))).", "assumption.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (g := fun a b : nat => cPair 3 (cPair a b)).", "assumption.", "assumption.", "apply codeForallIsPR.", "apply codeImpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply multIsPR."], "proof_pred": [], "time": 1.1975224018096924, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfFA2IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfFA3IsPR", "success": false, "proof_gt": ["unfold checkPrfFA3 in |- *.", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi1IsPR.", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))).", "replace (fun p : nat => cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPair 1 (cPair (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))) (cPair 1 (cPair (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))))) with (fun p : nat => codeImp (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) (codeImp (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))))); [ idtac | reflexivity ].", "apply compose1_2IsPR with (f := fun p : nat => cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))) (f' := fun p : nat => codeImp (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => codeImp (cPairPi1 (cPairPi2 (cPairPi2 p))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p))))) (g := fun a b : nat => cPair 3 (cPair a b)).", "assumption.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))).", "assumption.", "assumption.", "apply codeImpIsPR.", "apply codeForallIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 p))))) (f' := fun p : nat => cPair 3 (cPair (cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))))).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 p))) (g := fun a b : nat => cPair 3 (cPair a b)).", "assumption.", "assumption.", "apply codeForallIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => cPairPi1 (cPairPi2 (cPairPi2 (cPairPi2 p)))) (g := fun a b : nat => cPair 3 (cPair a b)).", "assumption.", "assumption.", "apply codeForallIsPR.", "apply codeImpIsPR.", "apply codeImpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR."], "proof_pred": [], "time": 1.1963787078857422, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfFA3IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQnIsPR", "success": false, "proof_gt": ["unfold checkPrfEQ1 in |- *.", "intros.", "apply filter10IsPR with (g := fun p : nat => charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0 * charFunction 2 beq_nat n (cPairPi1 p)).", "apply compose1_2IsPR with (f := fun p : nat => charFunction 2 beq_nat (cPairPi2 (cPairPi2 p)) 0) (f' := fun p : nat => charFunction 2 beq_nat n (cPairPi1 p)).", "apply compose1_2IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (f' := fun p : nat => 0).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply const1_NIsPR.", "apply eqIsPR.", "apply compose1_2IsPR with (f := fun p : nat => n).", "apply const1_NIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply multIsPR."], "proof_pred": ["intro.", "simpl in |- *.", "intuition.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case n.", "case H."], "time": 75.11375379562378, "num_tactics": 300, "proof_tree": {"current_proof_state": "checkPrfEQnIsPR", "used_tactic": null, "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "simpl in |- *.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case L.", "children": [{"current_proof_state": "Backtraced", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityFIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityRIsCorrect2 in |- *.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity2.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity3.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Functions.", "children": []}]}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeF.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeR.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "red in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityFIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityRIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeFInj in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeRInj in |- *.", "children": []}]}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case L.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Relations.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Functions.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case n.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Relations.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Functions.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case H.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityR in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityF in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityFIsCorrect2 in |- *.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case H0.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "case H6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H4.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case codeArityR.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "elim H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "elim H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "elim H6.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "elim H5.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "elim H4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity20.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}]}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Relations.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}]}, {"current_proof_state": "PROVING", "used_tactic": "case n.", "children": [{"current_proof_state": "Backtraced", "used_tactic": "simpl in |- *.", "children": [{"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityFIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityRIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "intro.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "red in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityR in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityF in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeFInj in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeRInj in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H0.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case H6.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "case L.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case n.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case H1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case H.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQ1IsPR", "success": false, "proof_gt": ["unfold checkPrfEQ1 in |- *.", "apply checkPrfEQnIsPR."], "proof_pred": [], "time": 1.2488319873809814, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfEQ1IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQ2IsPR", "success": false, "proof_gt": ["unfold checkPrfEQ2 in |- *.", "apply checkPrfEQnIsPR."], "proof_pred": [], "time": 1.2130184173583984, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfEQ2IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQ3IsPR", "success": false, "proof_gt": ["unfold checkPrfEQ3 in |- *.", "apply checkPrfEQnIsPR."], "proof_pred": [], "time": 1.2377512454986572, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfEQ3IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeAxmEqHelpIsPR", "success": false, "proof_gt": ["unfold codeAxmEqHelp in |- *.", "apply ind1ParamIsPR with (g := fun f : nat => f) (f := fun m rec f : nat => cPair 1 (cPair (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) rec)).", "apply filter110IsPR with (g := fun m rec : nat => codeImp (cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) rec).", "apply compose2_2IsPR with (f := fun m rec : nat => cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))) (g := fun m rec : nat => rec).", "apply filter10IsPR with (g := fun m : nat => cPair 0 (cPair (cPair 0 (m + m)) (cPair 0 (S (m + m))))).", "assert (forall g : nat -> nat, isPR 1 g -> isPR 1 (fun a : nat => cPair 0 (g a))).", "intros.", "apply compose1_2IsPR with (f := fun a : nat => 0).", "apply const1_NIsPR.", "assumption.", "apply cPairIsPR.", "apply H with (g := fun m : nat => cPair (cPair 0 (m + m)) (cPair 0 (S (m + m)))).", "apply compose1_2IsPR with (f := fun m : nat => cPair 0 (m + m)) (f' := fun m : nat => cPair 0 (S (m + m))).", "apply H with (g := fun m : nat => m + m).", "apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).", "apply idIsPR.", "apply idIsPR.", "apply plusIsPR.", "apply H with (g := fun m : nat => S (m + m)).", "apply compose1_1IsPR with (f := fun m : nat => m + m).", "apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).", "apply idIsPR.", "apply idIsPR.", "apply plusIsPR.", "apply succIsPR.", "apply cPairIsPR.", "apply pi2_2IsPR.", "apply codeImpIsPR.", "apply idIsPR."], "proof_pred": [], "time": 1.1970582008361816, "num_tactics": 20, "proof_tree": {"current_proof_state": "codeAxmEqHelpIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect2.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeNVars1IsPR", "success": false, "proof_gt": ["unfold codeNVars1 in |- *.", "apply indIsPR with (f := fun m rec : nat => S (cPair (cPair 0 (m + m)) rec)).", "apply compose2_1IsPR with (f := fun m rec : nat => cPair (cPair 0 (m + m)) rec).", "apply compose2_2IsPR with (f := fun m rec : nat => cPair 0 (m + m)) (g := fun m rec : nat => rec).", "apply filter10IsPR with (g := fun m : nat => cPair 0 (m + m)).", "apply compose1_2IsPR with (f := fun m : nat => 0) (f' := fun m : nat => m + m).", "apply const1_NIsPR.", "apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).", "apply idIsPR.", "apply idIsPR.", "apply plusIsPR.", "apply cPairIsPR.", "apply pi2_2IsPR.", "apply cPairIsPR.", "apply succIsPR."], "proof_pred": ["red in |- *.", "simpl in |- *.", "intuition.", "case L.", "intros.", "intuition.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case arity3."], "time": 62.76150727272034, "num_tactics": 300, "proof_tree": {"current_proof_state": "codeNVars1IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "red in |- *.", "children": [{"current_proof_state": "PROVING", "used_tactic": "simpl in |- *.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate codeArityRIsPR.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case L.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case wellFormedFormula.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case wellFormedTerm.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case var.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity19.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity0.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Relations.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction c.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Functions.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case wellFormedTerm.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case wellFormedFormula.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case arity.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity0.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity1.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity2.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "PROVING", "used_tactic": "case arity3.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeNVars2IsPR", "success": false, "proof_gt": ["unfold codeNVars2 in |- *.", "apply indIsPR with (f := fun m rec : nat => S (cPair (cPair 0 (S (m + m))) rec)).", "apply compose2_1IsPR with (f := fun m rec : nat => cPair (cPair 0 (S (m + m))) rec).", "apply compose2_2IsPR with (f := fun m rec : nat => cPair 0 (S (m + m))) (g := fun m rec : nat => rec).", "apply filter10IsPR with (g := fun m : nat => cPair 0 (S (m + m))).", "apply compose1_2IsPR with (f := fun m : nat => 0) (f' := fun m : nat => S (m + m)).", "apply const1_NIsPR.", "apply compose1_1IsPR with (f := fun m : nat => m + m).", "apply compose1_2IsPR with (f := fun m : nat => m) (f' := fun m : nat => m).", "apply idIsPR.", "apply idIsPR.", "apply plusIsPR.", "apply succIsPR.", "apply cPairIsPR.", "apply pi2_2IsPR.", "apply cPairIsPR.", "apply succIsPR."], "proof_pred": ["red in |- *.", "simpl in |- *.", "intuition.", "case L.", "intros.", "intuition.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case L.", "intros.", "case arity3."], "time": 62.41272974014282, "num_tactics": 300, "proof_tree": {"current_proof_state": "codeNVars2IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "red in |- *.", "children": [{"current_proof_state": "PROVING", "used_tactic": "simpl in |- *.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate codeArityRIsPR.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case L.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case L.", "children": [{"current_proof_state": "DepthLimit", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case L.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case wellFormedFormula.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case wellFormedTerm.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case var.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity19.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity.", "children": []}, {"current_proof_state": "DepthLimit", "used_tactic": "case arity0.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction arity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Relations.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction c.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "simple induction Functions.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case wellFormedTerm.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity11.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity12.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "case codeArityR.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case codeArityF.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "case wellFormedFormula.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "case arity.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity0.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity1.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "Backtraced", "used_tactic": "case arity2.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity3.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity4.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity5.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity6.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity7.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity8.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity9.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity10.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}]}, {"current_proof_state": "PROVING", "used_tactic": "case arity3.", "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity19.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity0.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim arity1.", "children": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeNVarsCorrect", "success": false, "proof_gt": ["intros.", "split.", "induction n as [| n Hrecn].", "simpl in |- *.", "reflexivity.", "simpl in |- *.", "rewrite Hrecn.", "induction (nVars L n).", "simpl in |- *.", "reflexivity.", "induction n as [| n Hrecn].", "simpl in |- *.", "reflexivity.", "simpl in |- *.", "rewrite Hrecn.", "induction (nVars L n).", "simpl in |- *.", "reflexivity."], "proof_pred": ["intro.", "elim notH.", "intros.", "split.", "elim notH.", "intro.", "elim t1.", "intros.", "elim equal.", "intro.", "elim t1.", "intros.", "elim equal.", "intro.", "elim t5.", "intros.", "elim equal.", "intro.", "elim t6.", "intros.", "elim equal.", "intro.", "elim t1.", "intros.", "elim equal.", "intro.", "elim t10.", "intros.", "elim equal.", "intro.", "elim t13.", "intros.", "elim equal.", "intro.", "elim t14.", "intros.", "elim equal.", "intro.", "elim t1.", "intros.", "elim equal.", "intro.", "elim t19."], "time": 244.07875084877014, "num_tactics": 300, "proof_tree": {"current_proof_state": "codeNVarsCorrect", "used_tactic": null, "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "split.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply notH.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "symmetry.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeF.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeR.", "children": []}]}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "intuition.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "red in |- *.", "children": []}]}]}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim notH.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "PROVING", "used_tactic": "split.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply notH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim notH.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t5.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t6.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t10.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t13.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t14.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim equal.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t19.", "children": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeOrIsPR", "success": false, "proof_gt": ["unfold codeOr in |- *.", "apply compose2_2IsPR with (f := fun a b : nat => codeNot a) (g := fun a b : nat => b).", "apply filter10IsPR.", "apply codeNotIsPR.", "apply pi2_2IsPR.", "apply codeImpIsPR."], "proof_pred": [], "time": 1.2292232513427734, "num_tactics": 20, "proof_tree": {"current_proof_state": "codeOrIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeAndIsPR", "success": false, "proof_gt": ["unfold codeAnd in |- *.", "apply compose2_1IsPR with (f := fun a b : nat => codeOr (codeNot a) (codeNot b)).", "apply compose2_2IsPR with (f := fun a b : nat => codeNot a) (g := fun a b : nat => codeNot b).", "apply filter10IsPR.", "apply codeNotIsPR.", "apply filter01IsPR.", "apply codeNotIsPR.", "apply codeOrIsPR.", "apply codeNotIsPR."], "proof_pred": [], "time": 1.2399406433105469, "num_tactics": 20, "proof_tree": {"current_proof_state": "codeAndIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "codeIffIsPR", "success": false, "proof_gt": ["unfold codeIff in |- *.", "apply compose2_2IsPR with (g := fun a b : nat => codeImp b a).", "apply codeImpIsPR.", "apply swapIsPR.", "apply codeImpIsPR.", "apply codeAndIsPR."], "proof_pred": [], "time": 1.263413429260254, "num_tactics": 20, "proof_tree": {"current_proof_state": "codeIffIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQ4IsPR", "success": false, "proof_gt": ["unfold checkPrfEQ4 in |- *.", "apply filter10IsPR with (g := fun p : nat => notZero (codeArityR (cPairPi2 (cPairPi2 p))) * charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p)))) (codeIff (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))) (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => notZero (codeArityR (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p)))) (codeIff (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))) (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))))) (cPairPi1 p)).", "apply compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityRIsPR.", "apply notZeroIsPR.", "apply compose1_2IsPR with (f := fun p : nat => codeAxmEqHelp (pred (codeArityR (cPairPi2 (cPairPi2 p)))) (codeIff (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))) (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))))).", "apply compose1_2IsPR with (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => codeIff (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))) (cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityRIsPR.", "apply predIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => cPair (S (S (S (S (cPairPi2 (cPairPi2 p)))))) (codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p)))))).", "apply compose1_2IsPR with (f := fun p : nat => S (S (S (S (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => codeNVars1 (pred (codeArityR (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (g := iterate S 4).", "assumption.", "apply iterateIsPR.", "apply succIsPR.", "apply compose1_1IsPR with (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityRIsPR.", "apply predIsPR.", "apply codeNVars1IsPR.", "apply cPairIsPR.", "apply compose1_2IsPR with (f := fun p : nat => S (S (S (S (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => codeNVars2 (pred (codeArityR (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)) (g := iterate S 4).", "assumption.", "apply iterateIsPR.", "apply succIsPR.", "apply compose1_1IsPR with (f := fun p : nat => pred (codeArityR (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityR (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityRIsPR.", "apply predIsPR.", "apply codeNVars2IsPR.", "apply cPairIsPR.", "apply codeIffIsPR.", "apply codeAxmEqHelpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply multIsPR."], "proof_pred": [], "time": 1.2176661491394043, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfEQ4IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfEQ5IsPR", "success": false, "proof_gt": ["unfold checkPrfEQ5 in |- *.", "apply filter10IsPR with (g := fun p : nat => notZero (codeArityF (cPairPi2 (cPairPi2 p))) * charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p)))) (cPair 0 (cPair (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))))) (cPairPi1 p)).", "assert (isPR 1 (fun p : nat => cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR; apply cPairPi2IsPR.", "apply compose1_2IsPR with (f := fun p : nat => notZero (codeArityF (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => charFunction 2 beq_nat (codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p)))) (cPair 0 (cPair (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))))) (cPairPi1 p)).", "apply compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityFIsPR.", "apply notZeroIsPR.", "apply compose1_2IsPR with (f := fun p : nat => codeAxmEqHelp (pred (codeArityF (cPairPi2 (cPairPi2 p)))) (cPair 0 (cPair (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))))))).", "apply compose1_2IsPR with (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p)))) (f' := fun p : nat => cPair 0 (cPair (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityFIsPR.", "apply predIsPR.", "apply compose1_2IsPR with (f := fun p : nat => cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (f' := fun p : nat => cPair (S (cPairPi2 (cPairPi2 p))) (codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p)))))) (g := fun a b : nat => cPair 0 (cPair a b)).", "apply compose1_2IsPR with (f := fun p : nat => S (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => codeNVars1 (pred (codeArityF (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply succIsPR.", "apply compose1_1IsPR with (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityFIsPR.", "apply predIsPR.", "apply codeNVars1IsPR.", "apply cPairIsPR.", "apply compose1_2IsPR with (f := fun p : nat => S (cPairPi2 (cPairPi2 p))) (f' := fun p : nat => codeNVars2 (pred (codeArityF (cPairPi2 (cPairPi2 p))))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply succIsPR.", "apply compose1_1IsPR with (f := fun p : nat => pred (codeArityF (cPairPi2 (cPairPi2 p)))).", "apply compose1_1IsPR with (f := fun p : nat => codeArityF (cPairPi2 (cPairPi2 p))).", "apply compose1_1IsPR with (f := fun p : nat => cPairPi2 (cPairPi2 p)).", "assumption.", "apply codeArityFIsPR.", "apply predIsPR.", "apply codeNVars2IsPR.", "apply cPairIsPR.", "apply compose2_2IsPR with (f := fun a b : nat => 0).", "apply filter10IsPR with (g := fun _ : nat => 0).", "apply const1_NIsPR.", "apply cPairIsPR.", "apply cPairIsPR.", "apply codeAxmEqHelpIsPR.", "apply cPairPi1IsPR.", "apply eqIsPR.", "apply multIsPR."], "proof_pred": [], "time": 1.223111629486084, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfEQ5IsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfIsPR", "success": false, "proof_gt": ["unfold checkPrf in |- *.", "apply compose2_3IsPR with (f1 := fun f p : nat => wellFormedFormula f) (f2 := fun f p : nat => checkPrfHelp (cPair f p)) (f3 := fun f p : nat => 0).", "apply filter10IsPR.", "unfold wellFormedFormula in |- *.", "apply wellFormedFormulaIsPR.", "apply codeArityFIsPR.", "apply codeArityRIsPR.", "apply compose2_1IsPR.", "apply cPairIsPR.", "apply checkPrfHelpIsPR.", "apply filter10IsPR with (g := fun _ : nat => 0).", "apply const1_NIsPR.", "apply switchIsPR."], "proof_pred": [], "time": 1.3368961811065674, "num_tactics": 20, "proof_tree": {"current_proof_state": "checkPrfIsPR", "used_tactic": null, "children": [{"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsPR.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "easy.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "exact impH.", "children": []}]}}, {"filename": "../data/goedel/checkPrf.json", "proof_name": "checkPrfCorrect1", "success": false, "proof_gt": ["intros.", "unfold checkPrf in |- *.", "rewrite (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR codeArityR codeArityRIsCorrect1).", "simpl in |- *.", "lazy beta delta [checkPrfHelp] in |- *.", "set (A := fun p0 recs : nat => let type := cPairPi1 (cPairPi2 p0) in switchPR type (switchPR (pred type) (switchPR (pred (pred type)) (switchPR (pred (pred (pred type))) (switchPR (pred (pred (pred (pred type)))) (switchPR (pred (pred (pred (pred (pred type))))) (switchPR (pred (pred (pred (pred (pred (pred type)))))) (switchPR (pred (pred (pred (pred (pred (pred (pred type))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred type)))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred (pred type))))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred type)))))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred type))))))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred type)))))))))))) (switchPR (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred (pred type))))))))))))) 0 (checkPrfEQ5 p0 recs)) (checkPrfEQ4 p0 recs)) (checkPrfEQ3 p0 recs)) (checkPrfEQ2 p0 recs)) (checkPrfEQ1 p0 recs)) (checkPrfFA3 p0 recs)) (checkPrfFA2 p0 recs)) (checkPrfFA1 p0 recs)) (checkPrfCP p0 recs)) (checkPrfIMP2 p0 recs)) (checkPrfIMP1 p0 recs)) (checkPrfGEN p0 recs)) (checkPrfMP p0 recs)) (checkPrfAXM p0 recs)) in *.", "induction p as [A0| Axm1 Axm2 A0 B p1 Hrecp1 p0 Hrecp0| Axm A0 v n p Hrecp| A0 B| A0 B C| A0 B| A0 v t| A0 v n| A0 B v| | | | R| f]; unfold evalStrongRec, evalComposeFunc, evalOneParamList, evalList in |- *; rewrite computeEvalStrongRecHelp; unfold compose2, evalComposeFunc, evalOneParamList, evalList in |- *; simpl in |- *; rewrite cPairProjections1.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ]; simpl in |- *.", "unfold checkPrfAXM in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ]; simpl in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "set (C := cPair (cPair (cPair 1 (cPair (codeFormula L codeF codeR A0) (codeFormula L codeF codeR B))) (codePrf L codeF codeR Axm1 (fol.impH L A0 B) p1)) (cPair (codeFormula L codeF codeR A0) (codePrf L codeF codeR Axm2 A0 p0))) in *.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold C at 1 in |- *.", "unfold checkPrfMP in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "repeat rewrite evalStrongRecHelp1.", "rewrite <- beq_nat_refl.", "rewrite Hrecp0.", "replace (cPair 1 (cPair (codeFormula L codeF codeR A0) (codeFormula L codeF codeR B))) with (codeFormula L codeF codeR (fol.impH L A0 B)); [ idtac | reflexivity ].", "rewrite Hrecp1.", "rewrite (wellFormedFormulaCorrect1 L codeF codeArityF codeArityFIsCorrect1 codeR codeArityR codeArityRIsCorrect1).", "simpl in |- *.", "replace (map (codeFormula L codeF codeR) (Axm1 ++ Axm2)) with (map (codeFormula L codeF codeR) Axm1 ++ map (codeFormula L codeF codeR) Axm2).", "rewrite codeAppCorrect.", "reflexivity.", "generalize (codeFormula L codeF codeR); intro.", "clear p1 A Hrecp1 Hrecp0 C.", "induction Axm1 as [| a Axm1 HrecAxm1].", "reflexivity.", "simpl in |- *.", "rewrite HrecAxm1.", "reflexivity.", "eapply lt_le_trans; [ idtac | apply cPairLe2 ].", "eapply le_lt_trans; [ idtac | apply cPairLt2 ].", "unfold C in |- *.", "apply cPairLe2.", "eapply lt_le_trans; [ idtac | apply cPairLe2 ].", "eapply le_lt_trans; [ idtac | apply cPairLt2 ].", "unfold C in |- *.", "apply cPairLe1.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfGEN in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "repeat rewrite evalStrongRecHelp1.", "rewrite Hrecp.", "unfold pred in |- *.", "rewrite codeFreeVarListFormulaCorrect.", "rewrite codeInCorrect.", "induction (In_dec eq_nat_dec v (freeVarListFormula L Axm)).", "elim n.", "assumption.", "replace (charFunction 2 beq_nat (cPair 3 (cPair v (codeFormula L codeF codeR A0))) (cPair 3 (cPair v (codeFormula L codeF codeR A0)))) with 1.", "simpl in |- *.", "reflexivity.", "simpl in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "eapply lt_le_trans; [ idtac | apply cPairLe2 ].", "eapply le_lt_trans; [ idtac | apply cPairLt2 ].", "apply cPairLe2.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfIMP1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfIMP2 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfCP in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfFA1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "rewrite codeSubFormulaCorrect.", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "rewrite (wellFormedTermCorrect1 L codeF codeArityF codeArityFIsCorrect1).", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfFA2 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "rewrite codeFreeVarFormulaCorrect.", "rewrite codeInCorrect.", "induction (In_dec eq_nat_dec v (freeVarFormula L A0)).", "elim n.", "assumption.", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfFA3 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "reflexivity.", "set (C := cPair 0 (cPair (codeTerm L codeF (fol.var L 0)) (codeTerm L codeF (fol.var L 0)))) in *.", "unfold A at 1 in |- *.", "cut (cPairPi1 (cPairPi2 (cPair C (cPair 9 0))) = 9); [ intro H; rewrite H; clear H | idtac ].", "simpl in |- *.", "unfold checkPrfEQ1 in |- *.", "rewrite (cPairProjections2 C (cPair 9 0)).", "rewrite (cPairProjections1 C (cPair 9 0)).", "rewrite (cPairProjections2 9 0).", "unfold C in |- *.", "unfold charFunction in |- *.", "rewrite <- beq_nat_refl.", "simpl in |- *.", "reflexivity.", "rewrite (cPairProjections2 C (cPair 9 0)).", "rewrite (cPairProjections1 9 0).", "reflexivity.", "set (C := cPair 1 (cPair (cPair 0 (cPair (codeTerm L codeF (fol.var L 0)) (codeTerm L codeF (fol.var L 1)))) (cPair 0 (cPair (codeTerm L codeF (fol.var L 1)) (codeTerm L codeF (fol.var L 0)))))) in *.", "unfold A at 1 in |- *.", "cut (cPairPi1 (cPairPi2 (cPair C (cPair 10 0))) = 10).", "generalize (cPairPi1 (cPairPi2 (cPair C (cPair 10 0)))).", "intros.", "rewrite H.", "simpl in |- *.", "unfold checkPrfEQ2 in |- *.", "replace (codeFormula L codeF codeR (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1)) (fol.equal L (fol.var L 1) (fol.var L 0)))) with C; [ idtac | reflexivity ].", "generalize C; intros.", "rewrite (cPairProjections2 C0 (cPair 10 0)).", "rewrite (cPairProjections2 10 0).", "rewrite (cPairProjections1 C0 (cPair 10 0)).", "unfold charFunction in |- *.", "repeat rewrite <- beq_nat_refl.", "reflexivity.", "rewrite (cPairProjections2 C (cPair 10 0)).", "rewrite (cPairProjections1 10 0).", "reflexivity.", "set (C := cPair 1 (cPair (cPair 0 (cPair (codeTerm L codeF (fol.var L 0)) (codeTerm L codeF (fol.var L 1)))) (cPair 1 (cPair (cPair 0 (cPair (codeTerm L codeF (fol.var L 1)) (codeTerm L codeF (fol.var L 2)))) (cPair 0 (cPair (codeTerm L codeF (fol.var L 0)) (codeTerm L codeF (fol.var L 2)))))))) in *.", "unfold A at 1 in |- *.", "cut (cPairPi1 (cPairPi2 (cPair C (cPair 11 0))) = 11).", "generalize (cPairPi1 (cPairPi2 (cPair C (cPair 11 0)))).", "intros.", "rewrite H.", "simpl in |- *.", "unfold checkPrfEQ3 in |- *.", "replace (codeFormula L codeF codeR (fol.impH L (fol.equal L (fol.var L 0) (fol.var L 1)) (fol.impH L (fol.equal L (fol.var L 1) (fol.var L 2)) (fol.equal L (fol.var L 0) (fol.var L 2))))) with C; [ idtac | reflexivity ].", "generalize C; intros.", "rewrite (cPairProjections2 C0 (cPair 11 0)).", "rewrite (cPairProjections1 C0 (cPair 11 0)).", "rewrite (cPairProjections2 11 0).", "unfold charFunction in |- *.", "repeat rewrite <- beq_nat_refl.", "reflexivity.", "rewrite (cPairProjections2 C (cPair 11 0)).", "rewrite (cPairProjections1 11 0).", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfEQ4 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "rewrite codeArityRIsCorrect1.", "replace (codeAxmEqHelp (pred (S (arity L (inl (Functions L) R)))) (codeIff (cPair (S (S (S (S (codeR R))))) (codeNVars1 (pred (S (arity L (inl (Functions L) R)))))) (cPair (S (S (S (S (codeR R))))) (codeNVars2 (pred (S (arity L (inl (Functions L) R)))))))) with (codeFormula L codeF codeR (AxmEq4 L R)).", "unfold charFunction in |- *.", "repeat rewrite <- beq_nat_refl.", "reflexivity.", "unfold AxmEq4 in |- *.", "clear A.", "simpl in |- *.", "induction (codeNVarsCorrect (arity L (inl (Functions L) R))).", "rewrite H.", "rewrite H0.", "clear H H0.", "induction (nVars L (arity L (inl (Functions L) R))).", "simpl in |- *.", "replace (codeIff (cPair (S (S (S (S (codeR R))))) (codeTerms L codeF (arity L (inl (Functions L) R)) a)) (cPair (S (S (S (S (codeR R))))) (codeTerms L codeF (arity L (inl (Functions L) R)) b))) with (codeFormula L codeF codeR (iffH L (fol.atomic L R a) (fol.atomic L R b))).", "generalize (arity L (inl (Functions L) R)).", "intros.", "induction n as [| n Hrecn].", "reflexivity.", "simpl in |- *.", "rewrite Hrecn.", "reflexivity.", "rewrite <- codeIffCorrect.", "reflexivity.", "unfold A at 1 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "simpl in |- *.", "unfold checkPrfEQ5 in |- *.", "repeat first [ rewrite cPairProjections1 | rewrite cPairProjections2 ].", "rewrite codeArityFIsCorrect1.", "replace (codeAxmEqHelp (pred (S (arity L (inr (Relations L) f)))) (cPair 0 (cPair (cPair (S (codeF f)) (codeNVars1 (pred (S (arity L (inr (Relations L) f)))))) (cPair (S (codeF f)) (codeNVars2 (pred (S (arity L (inr (Relations L) f))))))))) with (codeFormula L codeF codeR (AxmEq5 L f)).", "unfold charFunction in |- *.", "repeat rewrite <- beq_nat_refl.", "reflexivity.", "unfold AxmEq5 in |- *.", "clear A.", "simpl in |- *.", "induction (codeNVarsCorrect (arity L (inr (Relations L) f))).", "rewrite H.", "rewrite H0.", "clear H H0.", "induction (nVars L (arity L (inr (Relations L) f))).", "simpl in |- *.", "replace (cPair 0 (cPair (cPair (S (codeF f)) (codeTerms L codeF (arity L (inr (Relations L) f)) a)) (cPair (S (codeF f)) (codeTerms L codeF (arity L (inr (Relations L) f)) b)))) with (codeFormula L codeF codeR (fol.equal L (fol.apply L f a) (fol.apply L f b))).", "generalize (arity L (inr (Relations L) f)).", "intros.", "induction n as [| n Hrecn].", "reflexivity.", "simpl in |- *.", "rewrite Hrecn.", "reflexivity.", "reflexivity."], "proof_pred": ["intro.", "intro.", "intuition.", "elim H1.", "intros.", "case H1.", "intro.", "case t0.", "intros.", "case H1.", "intro.", "case H1.", "elim H1.", "intro.", "intuition.", "elim H4.", "intros.", "elim H1.", "intro.", "elim t9.", "intros.", "elim p.", "intro.", "simpl in |- *.", "elim H1.", "intros.", "elim t14.", "intro.", "elim p.", "intro.", "elim p.", "elim H1.", "intros.", "elim p.", "elim H1.", "intros.", "elim t17.", "intro.", "elim p.", "intro.", "elim p."], "time": 375.58488941192627, "num_tactics": 300, "proof_tree": {"current_proof_state": "checkPrfCorrect1", "used_tactic": null, "children": [{"current_proof_state": "Backtraced", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "symmetry.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply impH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply notH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "Backtraced", "used_tactic": "symmetry.", "children": [{"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply Prf.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "symmetry.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "f_equal.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "omega.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeFInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeRInj.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply equal.", "children": []}]}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "symmetry.", "children": []}]}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply forallH.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}]}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "discriminate.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "apply codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "case l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case H1.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case t0.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "case l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case H1.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "case l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "case H1.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "assumption.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intuition.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H4.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t9.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "PROVING", "used_tactic": "simpl in |- *.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityFIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityRIsCorrect2 in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityR in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "unfold codeArityF in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "unfold wellFormedFormula in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "unfold wellFormedTerm in |- *.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t14.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim apply.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim atomic.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "rewrite codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "f_equal.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "tauto.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intuition.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "elim l.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim H1.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intros.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "reflexivity.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "trivial.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect2.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect2.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim t17.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "PROVING", "used_tactic": "intro.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "right.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "split.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityFIsCorrect1.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "elim codeArityRIsCorrect1.", "children": []}, {"current_proof_state": "PROVING", "used_tactic": "elim p.", "children": [{"current_proof_state": "GoalDouble", "used_tactic": "intro.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "intros.", "children": []}, {"current_proof_state": "GoalDouble", "used_tactic": "simpl in |- *.", "children": []}, {"current_proof_state": "ERROR", "used_tactic": "left.", "children": []}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}}]}